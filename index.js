// Generated by LiveScript 1.6.0
(function(){
  var syntax, std, con, fet, tostr, tobuf, valueMap, keywordMap, concatMap, runStream, out$ = typeof exports != 'undefined' && exports || this;
  out$.syntax = syntax = {
    keyword: new RegExp("@.+"),
    value: new RegExp("$[\\w\\_]+", "ig"),
    argsc: /[^\(\)]+(?=\))/g
  };
  std = {
    node: true,
    read: function(fname){
      if (!fname) {
        return new Promise(function(res){
          return process.stdin.once("data", function(it){
            process.stdin.end();
            return res(it.toString().slice(0, -1));
          });
        });
      } else {
        return require("fs").readFileSync(fname);
      }
    },
    write: function(string, fname){
      if (!fname) {
        return process.stdout.write(string.toString());
      } else {
        return require("fs").writeFileSync(fname, string);
      }
    }
  };
  con = {
    _history: "",
    node: true,
    read: function(){
      return this._history;
    },
    write: function(){
      var string, res$, i$, to$;
      res$ = [];
      for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      string = res$;
      console.log.apply(this, string);
      return this._history += string.join(" ").toString();
    }
  };
  fet = {
    _body: "",
    node: true,
    read: function(){
      return this._body;
    },
    write: async function(url){
      return this._body = (await (await fetch(url)).text());
    }
  };
  tostr = {
    _string: "",
    node: true,
    read: function(){
      return this._string;
    },
    write: function(ns){
      return this._string = ns.toString();
    }
  };
  tobuf = {
    _buf: void 8,
    node: true,
    read: function(){
      return this._buf;
    },
    write: function(string){
      return Buffer.from(string);
    }
  };
  out$.valueMap = valueMap = new Map();
  valueMap.set("Std", std);
  valueMap.set("Fetch", fet);
  valueMap.set("Console", con);
  valueMap.set("ToString", tostr);
  out$.keywordMap = keywordMap = new Map();
  keywordMap.set("@log", function(strings, values){
    console.log(strings.join(" "));
    return {
      _value: strings.join(" "),
      node: true,
      read: function(){
        return this._value;
      },
      write: function(value){
        return this._value += value;
      }
    };
  });
  keywordMap.set("@val", function(args, values){
    values.set(args[0], {
      _value: JSON.parse(args.join(" ")),
      node: true,
      read: function(){
        return this._value;
      },
      write: function(value){
        var err;
        try {
          return this._value += value;
        } catch (e$) {
          err = e$;
          return this._value = import$(clone$(value), this._value);
        }
      }
    });
    return values.get(args[0]);
  });
  out$.concatMap = concatMap = function(){
    var m, res$, i$, to$, md, len$, map;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    m = res$;
    md = new Map;
    for (i$ = 0, len$ = m.length; i$ < len$; ++i$) {
      map = m[i$];
      map.forEach(fn$);
    }
    return md;
    function fn$(val, key){
      return md.set(key, value);
    }
  };
  out$.runStream = runStream = async function(code, values, keywords){
    var codeBlocks, i$, len$, block, allnode, localValues, j$, len1$, node, valuekeys, k$, len2$, vk, addVal, fargs, err, fn2$ = async function(){
      var nodereturn, index, ref$, nodeclass, args, res$, i$, ref1$, len$, arg;
      nodereturn = [];
      for (index in ref$ = localValues) {
        nodeclass = ref$[index];
        res$ = [];
        for (i$ = 0, len$ = (ref1$ = nodeclass.args).length; i$ < len$; ++i$) {
          arg = ref1$[i$];
          if (arg.trim().indexOf("$") === 0) {
            res$.push((await values.get(arg.trim().slice(1)).read()));
          } else {
            res$.push(JSON.parse(arg.trim()));
          }
        }
        args = res$;
        (await nodeclass.node.write.apply(nodeclass.node, (index > 0
          ? [nodereturn[index - 1]]
          : [(await nodeclass.node.read())] || []).concat(args)));
        if (Number(index) + 1 !== localValues.length) {
          nodereturn.push((await nodeclass.node.read.apply(nodeclass.node, args)));
        }
      }
    };
    values == null && (values = valueMap);
    keywords == null && (keywords = keywordMap);
    codeBlocks = code.split(";;;");
    for (i$ = 0, len$ = codeBlocks.length; i$ < len$; ++i$) {
      block = codeBlocks[i$];
      allnode = block.split("\n");
      localValues = [];
      for (j$ = 0, len1$ = allnode.length; j$ < len1$; ++j$) {
        node = allnode[j$];
        node = node.trim();
        if (syntax.keyword.test(node)) {
          valuekeys = node.match(syntax.value) || [];
          for (k$ = 0, len2$ = valuekeys.length; k$ < len2$; ++k$) {
            vk = valuekeys[k$];
            node = node.replace("$" + vk, (await values.get(vk).read().toString()));
          }
          addVal = {
            node: keywords.get(node.split(" ")[0])(node.split(" ").slice(1), values),
            args: []
          };
          localValues.push(addVal);
        } else {
          fargs = node.match(syntax.argsc);
          node = node.replace(new RegExp("\\([^\\(\\)]+\\)", "g"), "");
          if (node.indexOf("$") === 0) {
            addVal = {
              node: values.get(node.slice(1)),
              args: fargs || []
            };
            localValues.push(addVal);
          } else if (node !== "") {
            try {
              addVal = {
                node: {
                  node: true,
                  _value: JSON.parse(node),
                  read: fn$,
                  write: fn1$
                },
                args: fargs || []
              };
              localValues.push(addVal);
            } catch (e$) {
              err = e$;
            }
          }
        }
      }
      (await fn2$)();
    }
    return values;
    function fn$(){
      return this._value;
    }
    function fn1$(value){
      return this._value = value;
    }
  };
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
}).call(this);
