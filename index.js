// Generated by LiveScript 1.6.0
(function(){
  var syntax, std, con, fet, cstr, tou, pau, json, pobj, jsn, tostr, tobuf, clear, valueMap, keywordMap, concatMap, runStream, out$ = typeof exports != 'undefined' && exports || this;
  out$.syntax = syntax = {
    keyword: new RegExp("@.+"),
    value: new RegExp("$[\\w\\_]+", "ig"),
    argsc: /[^\(\)]+(?=\))/g
  };
  std = {
    node: true,
    read: function(fname){
      if (!fname) {
        return new Promise(function(res){
          return process.stdin.once("data", function(it){
            process.stdin.end();
            return res(it.toString().slice(0, -1));
          });
        });
      } else {
        return require("fs").readFileSync(fname);
      }
    },
    write: function(string, fname){
      if (!fname) {
        return process.stdout.write(string.toString());
      } else {
        return require("fs").writeFileSync(fname, string);
      }
    }
  };
  con = {
    _history: "",
    node: true,
    read: function(){
      return this._history;
    },
    write: function(){
      var string, res$, i$, to$;
      res$ = [];
      for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      string = res$;
      console.log.apply(this, string);
      return this._history += string.join(" ").toString();
    }
  };
  fet = {
    _body: "",
    node: true,
    read: function(){
      return this._body;
    },
    write: async function(url, json){
      var i$, len$, link, results$ = [];
      json == null && (json = false);
      if (Array.isArray(url)) {
        for (i$ = 0, len$ = url.length; i$ < len$; ++i$) {
          link = url[i$];
          results$.push(this.write(link));
        }
        return results$;
      } else {
        if (json) {
          return this._body = (await (await fetch(url)).json());
        } else {
          return this._body = (await (await fetch(url)).text());
        }
      }
    }
  };
  cstr = {
    _ret: void 8,
    node: true,
    read: function(){
      return this._ret;
    },
    write: function(text, string, re){
      re == null && (re = false);
      if (typeof text === "string") {
        if (re) {
          return this._ret = (string || "") + text;
        } else {
          return this._ret = text + (string || "");
        }
      } else {
        return this._ret = import$(clone$(text), string || {});
      }
    }
  };
  tou = {
    _ret: "",
    node: true,
    read: function(){
      return this._ret;
    },
    write: function(string){
      return this._ret = encodeURI(string);
    }
  };
  pau = {
    _ret: "",
    node: true,
    read: function(){
      return this._ret;
    },
    write: function(string){
      return this._ret = decodeURI(string);
    }
  };
  json = {
    _ret: void 8,
    node: true,
    read: function(){
      return this._ret;
    },
    write: function(string, sj){
      return this._ret = typeof string === "string"
        ? JSON.parse(string)
        : JSON.stringify(string, 0, sj);
    }
  };
  pobj = {
    _value: void 8,
    node: true,
    read: function(){
      return this._value;
    },
    write: function(obj){
      var keys, res$, i$, to$, nobj, nvalue, len$, key;
      res$ = [];
      for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      keys = res$;
      nobj = obj;
      nvalue = void 8;
      for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
        key = keys[i$];
        nvalue = nobj[key];
        nobj = nvalue;
      }
      return this._value = nvalue;
    }
  };
  jsn = {
    _ret: void 8,
    node: true,
    read: function(){
      return this._ret;
    },
    write: function(){
      var arg, res$, i$, to$;
      res$ = [];
      for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      arg = res$;
      return this._ret = eval(arg[0]).apply(global, arg.slice(1));
    }
  };
  tostr = {
    _string: "",
    node: true,
    read: function(){
      return this._string;
    },
    write: function(ns){
      return this._string = ns.toString();
    }
  };
  tobuf = {
    _buf: void 8,
    node: true,
    read: function(){
      return this._buf;
    },
    write: function(string){
      return this._buf = Buffer.from(string);
    }
  };
  clear = {
    read: function(it){
      return it;
    },
    write: function(){}
  };
  out$.valueMap = valueMap = new Map();
  valueMap.set("Std", std);
  valueMap.set("Fetch", fet);
  valueMap.set("Console", con);
  valueMap.set("JsFunc", jsn);
  valueMap.set("Json", json);
  valueMap.set("ToUrl", tou);
  valueMap.set("ParseObject", pobj);
  valueMap.set("ParseUrl", pau);
  valueMap.set("Concat", cstr);
  valueMap.set("ToString", tostr);
  valueMap.set("ToBuffer", tobuf);
  valueMap.set("ClearTo", clear);
  out$.keywordMap = keywordMap = new Map();
  keywordMap.set("@log", function(strings, values){
    console.log(strings.join(" "));
    return {
      _value: strings.join(" "),
      node: true,
      read: function(){
        return this._value;
      },
      write: function(value){
        return this._value += value;
      }
    };
  });
  keywordMap.set("@val", function(args, values){
    values.set(args[0], {
      _value: function(){
        var err;
        try {
          return JSON.parse(args.slice(1).join(" "));
        } catch (e$) {
          err = e$;
          return args.slice(1).join(" ");
        }
      }(),
      node: true,
      read: function(){
        return this._value;
      },
      write: function(value){
        var err;
        try {
          return this._value += value;
        } catch (e$) {
          err = e$;
          return this._value = import$(clone$(value), this._value);
        }
      }
    });
    return values.get(args[0]);
  });
  out$.concatMap = concatMap = function(){
    var m, res$, i$, to$, md, len$, map;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    m = res$;
    md = new Map;
    for (i$ = 0, len$ = m.length; i$ < len$; ++i$) {
      map = m[i$];
      map.forEach(fn$);
    }
    return md;
    function fn$(val, key){
      return md.set(key, value);
    }
  };
  out$.runStream = runStream = async function(code, values, keywords){
    var codeBlocks, i$, len$, block, allnode, localValues, j$, len1$, node, valuekeys, k$, len2$, vk, addVal, fargs, err, fn2$ = async function(){
      var nodereturn, index, ref$, nodeclass, args, res$, i$, ref1$, len$, arg;
      nodereturn = [];
      for (index in ref$ = localValues) {
        nodeclass = ref$[index];
        res$ = [];
        for (i$ = 0, len$ = (ref1$ = nodeclass.args).length; i$ < len$; ++i$) {
          arg = ref1$[i$];
          if (arg.trim().indexOf("$") === 0) {
            res$.push((await values.get(arg.trim().slice(1)).read()));
          } else {
            res$.push(JSON.parse(arg.trim()));
          }
        }
        args = res$;
        (await nodeclass.node.write.apply(nodeclass.node, (index > 0
          ? [nodereturn[index - 1]]
          : [(await nodeclass.node.read())] || []).concat(args)));
        if (Number(index) + 1 !== localValues.length) {
          nodereturn.push((await nodeclass.node.read.apply(nodeclass.node, args)));
        }
      }
    };
    values == null && (values = valueMap);
    keywords == null && (keywords = keywordMap);
    codeBlocks = code.split(";;;");
    for (i$ = 0, len$ = codeBlocks.length; i$ < len$; ++i$) {
      block = codeBlocks[i$];
      allnode = block.split("\n");
      localValues = [];
      for (j$ = 0, len1$ = allnode.length; j$ < len1$; ++j$) {
        node = allnode[j$];
        node = node.trim();
        if (syntax.keyword.test(node)) {
          valuekeys = node.match(syntax.value) || [];
          for (k$ = 0, len2$ = valuekeys.length; k$ < len2$; ++k$) {
            vk = valuekeys[k$];
            node = node.replace("$" + vk, (await values.get(vk).read().toString()));
          }
          addVal = {
            node: keywords.get(node.split(" ")[0])(node.split(" ").slice(1), values),
            args: []
          };
          localValues.push(addVal);
        } else {
          fargs = node.match(syntax.argsc);
          node = node.replace(new RegExp("\\([^\\(\\)]+\\)", "g"), "");
          if (node.indexOf("$") === 0) {
            addVal = {
              node: values.get(node.slice(1)),
              args: fargs || []
            };
            localValues.push(addVal);
          } else if (node !== "") {
            try {
              addVal = {
                node: {
                  node: true,
                  _value: JSON.parse(node),
                  read: fn$,
                  write: fn1$
                },
                args: fargs || []
              };
              localValues.push(addVal);
            } catch (e$) {
              err = e$;
            }
          }
        }
      }
      (await fn2$)();
    }
    return values;
    function fn$(){
      return this._value;
    }
    function fn1$(value){
      return this._value = value;
    }
  };
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
}).call(this);
